---
title: 正则表达式
---
import { RenderImg } from '../../../src/common/index.js';

正则表达式的"非"，代表不想匹配某个字符
例如：
```javascript
const str = 'helloword123'
const reg = /[^hello]/g
```
 `[^]`内的多个字符是"或"的关系存在的，即它们并不是一个整体，`/[^hello]/g` 表示 非 `h` 非 `e` 非 `l` 非 `o`，并不能理解为非`(hello)`，所以匹配结果是 `w` 和 `rd123`。

如果我们就是想匹配非某个字符串怎么办呢这时我们需要用到正则表达式的断言
正则表达式的先行断言和后行断言一共有 4 种形式：
* `(?=pattern)` 零宽正向先行断言
* `(?!pattern)` 零宽负向先行断言
* `(?<=pattern)` 零宽正向后行断言
* `(?<!pattern)` 零宽负向后行断言

这里面的 pattern 是一个正则表达式。
如同 `^` 代表开头，`$` 代表结尾，`\b` 代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中不占用字符，所以被称为"零宽"。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。
下面分别举例来说明这 4 种断言的含义。

## 1. 零宽正向先行断言
`(?=pattern)` 代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配 pattern。

```javascript
var str = '<div>anterone'
var reg = /^(?=<)<[^>]+>\w+/
```

<RenderImg src="../../img/javascript/Kdivantzone.png"/>

正则表达式中获取控制权，首先由位置0开始匹配，它匹配开始位置0，匹配成功，然后控制权转交给 `(?=<)`，由于 `(?=<)` 是零宽的，所以 `(?=<)` 也是从位置0开始匹配，它要求所在的位置右侧必须是字符 `<`，位置0的右侧恰好是字符串 `<`，匹配成功，然后控制权交给 `<`,由于 `(?=<)` 是零宽的，所以 `<` 也是从位置0开始匹配，于是匹配成功。

## 2. 负向零宽断言
`(?!pattern)`代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配 pattern。
```javascript
var str = 'abZW863ab88';
var reg=/ab(?![A-Z])/g;
```
<RenderImg src="../../img/javascript/abZW863ab88.png"/>

首先由正则表达式的字符 `a` 获取控制权，从位置0开始匹配，匹配字符 `a` 成功，然后控制权转交给 `b`，从位置1处开始匹配，匹配字符 `b` 成功，然后控制权转交给 `(?![A-Z])`，它从位置2处开始匹配，它要求所在位置的右边不能够是任意一个大写字母，而位置2的右边是大写字母  `Z`，于是匹配失败，然后控制权重新交给了 `a`，并从位置1开始尝试，然后失败，控制权再次转交给 `a`，从位置2开始尝试，依然失败，如此往复，知道在位置7处匹配成功，然后控制权转交给 `b`，然后从位置8处开始尝试匹配，匹配成功，然后将控制权转交给 `(?![A-Z])`，它从位置9开始尝试匹配，匹配成功，但是它不会真正匹配 `ab` 后面的字符，随意最终返回的结果是位置7-9的字符 `ab`。

## 3. 零宽正向后行断言
`(?<=pattern)`代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配 pattern。
例如：对 `regex represents regular expression` 这个字符串，有 4 个单词，要想匹配单词内部的 `re`，但不匹配单词开头的 `re`，可以用 `(?<=\w)re`，单词内部的 `re`，在 `re` 前面应该是一个单词字符。
之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。

## 4. 零宽负向后行断言
`(?<!pattern)` 代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配 pattern。
例如：对 `regex represents regular expression` 这个字符串，要想匹配单词开头的 `re`，可以用 `(?<!\w)re`。单词开头的 `re`，在本例中，也就是指不在单词内部的 `re`，即 `re` 前面不是单词字符。当然也可以用 `\bre` 来匹配。



##例子

`/^((?!hello).)+$/`
由于断言 `(?!hello)`是不占位的，后跟的 `.` 在原位置匹配任意字符，再用括号将其括起来，用 `+` 重复一次或多次，前后加上 `^` 和 `$`，若是字符串中存在 `hello`，则匹配到 `h` 字符之前的时候，断言 `(?!hello)` 匹配失败，正则匹配结果为false， 若是字符串中不存在 `hello`，则匹配结果是整个字符串。

### 匹配 & 和 ; 之间不含有 test 的字符
```javascript
const str = "hello&nbsp;&test1;test&qout;";
const reg = /&((?!test).)+;/g
// 匹配结果：&nbsp; 和 &qout;
```

### 匹配不含有&lt;img&gt;标签的&lt;div&gt;&lt;/div&gt;标签
```javascript
const str = "<div id='1'><img class='xx'></div><div id='1'><input type=''text"></div>";
const reg = /<div[^>]*>((?!<img[^>]*>).)+</div>/g;
// 匹配结果：<div id='1'><input type=''text"></div>
```

## 5. 中括号中需要转义的四个特殊字符为

<RenderImg
  src="../../img/javascript/regexp.png"
  width="600px"/>

1. 正则表达式中括号内含有 `^` 的情况

  `^` 放在最前面时，有特定的含义,此时需要转义；否则不需要。

2. 含有 `-` 的情况

  `-` 放在中间时，有特定的含义,此时需要转义；否则不需要。

3. 含有 `[]` 的情况

  `[]` 有特定的含义 故一定需要转义。

4. 含有 `\` 的情况

  `\` 本身就是转义字符，故也是一定需要转义。

